#pragma config(Motor,  motorA,          rightWheel,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftWheel,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define L 0 //left index
#define R 1 //right index
task main()
{
	float wheelDia = 2; // diameter of wheel
	float wheelBase = 4; // distance between the two wheels

	long ticks[3][2]; // (left ticks, right ticks)
	long wheelVelocity[3][2]; // (left angular velocity, right angular velocity)
	long totLinear[3]; // robot linear velocity
	long totAngular[3]; // robot angular velocity

	float orientation[3][3]; // variable for the final orientation (x,y,theta)

	// (leftWheel, rightWheel)
	int inputs = 3;
	int motorSpeed[3][2] = {
		{50,40},
		{-30,40},
		{30,0}
	}; // TA defined ints

	for (int i = 0; i < inputs; i++){
		clearTimer(T1); // set timer T1 to 0

		nMotorEncoder[leftWheel] = 0; // reset the left wheel encoder
		nMotorEncoder[rightWheel] = 0; // reset the right wheel encoder

		while(time1[T1] < 5000) // run for 5 seconds
		{
			motor[leftWheel] = motorSpeed[i][L]; // set left wheel speed
			motor[rightWheel] = motorSpeed[i][R]; // set right wheel speed
		}

		ticks[i][L] = nMotorEncoder(leftWheel); // record ticks for left wheel
		ticks[i][R] = nMotorEncoder(rightWheel); // record ticks for right wheel

		wheelVelocity[i][L] = ((ticks[i][L])/5) * (PI / 180) * (wheelDia/2); // linear velocity of left wheel
		wheelVelocity[i][R] = ((ticks[i][R])/5) * (PI / 180) * (wheelDia/2); // linear velocity of right wheel

		totLinear[i] = (wheelVelocity[i][L] + wheelVelocity[i][R]) / 2; // linear velocity for robot
		totAngular[i] = (wheelVelocity[i][R] - wheelVelocity[i][L]) / wheelBase; // angular velocity for robot

		float k[4][3]; // numerical integrator: Runge - Kutta variable holder

		//initial orientation is (0,0)
		// numerical integrator described in the lab handout
		k[0][0] = (totLinear[i]) * cos(0);
		k[0][1] = (totLinear[i]) * sin(0);
		k[0][2] = totAngular[i];

		k[1][0] = ((totLinear[i]) * cos(0 + (5/2) * k[0][2]));
		k[1][1] = ((totLinear[i]) * sin(0 + (5/2) * k[0][2]));
		k[1][2] = totAngular[i];

		k[2][0] = ((totLinear[i]) * cos(0 + (5/2) * k[1][2]));
		k[2][1] = ((totLinear[i]) * sin(0 + (5/2) * k[1][2]));
		k[2][2] = totAngular[i];

		k[3][0] = ((totLinear[i]) * cos(0 + (5) * k[2][2]));
		k[3][1] = ((totLinear[i]) * sin(0 + (5) * k[2][2]));
		k[3][2] = totAngular[i];

		orientation[i][0] = (k[0][0] + 2*(k[1][0]+k[2][0]) + k[3][0]) * (5/6); //x
		orientation[i][1] = (k[0][1] + 2*(k[1][1]+k[2][1]) + k[3][1]) * (5/6); //y
		orientation[i][2] = (k[0][2] + 2*(k[1][2]+k[2][2]) + k[3][2]) * (5/6); //theta
	}

	//final orienation calculation
	float finalX = 0;
	for (int i = 0; i < 3; i++){
		finalX += orientation[i][0]; //add up all the previous values
	}

	float finalY = 0;
	for (int i = 0; i < 3; i++){
		finalY += orientation[i][1]; //add up all the previous values
	}

	float finalTheta = 0;
	for (int i = 0; i < 3; i++){
		finalTheta += orientation[i][2]; //add up all the previous values
	}


}
